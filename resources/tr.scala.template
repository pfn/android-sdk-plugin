package %1$s

import android.annotation.TargetApi
import android.app.{Activity,Dialog}
import android.content.Context
import android.content.res.{TypedArray,XmlResourceParser}
import android.graphics.drawable.Drawable
import android.os.Build
import android.view.{View,ViewGroup,LayoutInflater, MenuInflater, Menu, MenuItem}
import android.view.animation.{Animation, AnimationUtils, Interpolator}
import android.animation.{Animator, AnimatorInflater}

import scala.annotation.implicitNotFound

case class TypedResource[A](id: Int) extends AnyVal
case class TypedLayout[A](id: Int)%2$s
case class TypedRes[A](resid: Int) extends AnyVal {
  def value(implicit ev: TypedResource.TypedResValueOp[A], c: Context): ev.T = ev.resourceValue(resid)(c)
  def unapply[T](t: T)(implicit ex: TypedResource.Extractor[A,T]): Boolean = ex.matches(resid, t)
}

object TR {
%3$s

  object layout {
%4$s
  }

%5$s
}

trait TypedFindView extends Any {
  protected %6$s
  final def findView[A](tr: TypedResource[A]): A = findViewById(tr.id).asInstanceOf[A]
}

object TypedResource {
  sealed trait ResAnim
  sealed trait ResAnimator
  sealed trait ResAttr
  sealed trait ResBool
  sealed trait ResColor
  sealed trait ResDimen
  sealed trait ResDrawable
  sealed trait ResFraction
  sealed trait ResInteger
  sealed trait ResInterpolator
  sealed trait ResMenu
  sealed trait ResMenuItem
  sealed trait ResMipMap
  sealed trait ResPlurals
  sealed trait ResRaw
  sealed trait ResString
  sealed trait ResStyle
  sealed trait ResTransition
  sealed trait ResXml

  // specializations of ResArray
  sealed trait ResStringArray
  sealed trait ResIntegerArray
  sealed trait ResArray

  @implicitNotFound("don't know how to .value for ${A}, create a TypedResValueOp[${A}] manually")
  trait TypedResValueOp[A] {
    type T
    def resourceValue(resid: Int)(implicit c: Context): T
  }

  @implicitNotFound("didn't find an extractor for ${A},${T}; create an Extractor[${A},${T}] manually")
  trait Extractor[A,T] {
    def matches(resid: Int, t: T): Boolean
  }

  implicit class TypedView(val v: View) extends AnyVal with TypedFindView {
    %6$s = v.findViewById(id)
  }
  implicit class TypedActivity(val a: Activity) extends AnyVal with TypedFindView {
    %6$s = a.findViewById(id)
  }
  implicit class TypedDialog(val d: Dialog) extends AnyVal with TypedFindView {
    %6$s = d.findViewById(id)
  }
  implicit class TypedLayoutInflater(val l: LayoutInflater) extends AnyVal {
    def inflate[A <: View](resource: TypedLayout[A], root: ViewGroup, attachToRoot: Boolean): A = {
      val v = l.inflate(resource.id, root, attachToRoot)
      val a = if(root != null && attachToRoot) root.getChildAt(root.getChildCount - 1) else v
      a.asInstanceOf[A]
    }
    def inflate[A <: View](resource: TypedLayout[A], root: ViewGroup): A =
      inflate(resource, root, true)
    def inflate[A <: View](resource: TypedLayout[A]): A =
      inflate(resource, null, false)
  }

  implicit class TypedResMenuInflater(val mi: MenuInflater) extends AnyVal {
    def inflate(menuRes: TypedRes[ResMenu], menu: Menu): Unit = {
      mi.inflate(menuRes.resid, menu)
    }
  }

  implicit class TypedResMenuOps(val m: Menu) extends AnyVal {
    def findItem(item: TypedRes[ResMenuItem]): MenuItem = {
      m.findItem(item.resid)
    }
  }

  implicit val trAnimValueOp: TypedResValueOp[ResAnim] { type T = Animation } = new TypedResValueOp[ResAnim] {
    type T = Animation
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
      AnimationUtils.loadAnimation(c, resid)
  }
  implicit val trAnimatorValueOp: TypedResValueOp[ResAnimator] { type T = Animator } = new TypedResValueOp[ResAnimator] {
    type T = Animator
    @TargetApi(11)
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
      if (android.os.Build.VERSION.SDK_INT >= 11)
       AnimatorInflater.loadAnimator(c, resid)
      else ???
  }
  implicit val trIntegerArrayValueOp: TypedResValueOp[ResIntegerArray] { type T = Array[Int] } = new TypedResValueOp[ResIntegerArray] {
    type T = Array[Int]
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
      c.getResources.getIntArray(resid)
  }
  implicit val trStringArrayValueOp: TypedResValueOp[ResStringArray] { type T = Array[String] } = new TypedResValueOp[ResStringArray] {
    type T = Array[String]
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
      c.getResources.getStringArray(resid)
  }
  implicit val trTypedArrayValueOp: TypedResValueOp[ResArray] { type T = TypedArray } = new TypedResValueOp[ResArray] {
    type T = TypedArray
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
      c.getResources.obtainTypedArray(resid)
  }
  implicit val trBoolValueOp: TypedResValueOp[ResBool] { type T = Boolean } = new TypedResValueOp[ResBool] {
    type T = Boolean
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
      c.getResources.getBoolean(resid)
  }
  implicit val trColorValueOp: TypedResValueOp[ResColor] { type T = Int } = new TypedResValueOp[ResColor] {
    type T = Int
    @TargetApi(23)
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
%7$s
  }
  implicit val trDimenValueOp: TypedResValueOp[ResDimen] { type T = Int } = new TypedResValueOp[ResDimen] {
    type T = Int
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
      c.getResources.getDimensionPixelSize(resid)
  }
  implicit val trDrawableValueOp: TypedResValueOp[ResDrawable] { type T = Drawable } = new TypedResValueOp[ResDrawable] {
    type T = Drawable
    @TargetApi(21)
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
%8$s
  }
  implicit val trIntegerValueOp: TypedResValueOp[ResInteger] { type T = Int } = new TypedResValueOp[ResInteger] {
    type T = Int
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
      c.getResources.getInteger(resid)
  }
  implicit val trInterpolatorValueOp: TypedResValueOp[ResInterpolator] { type T = Interpolator } = new TypedResValueOp[ResInterpolator] {
    type T = Interpolator
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
      AnimationUtils.loadInterpolator(c, resid)
  }
  implicit val trMipMapValueOp: TypedResValueOp[ResMipMap] { type T = Drawable } = new TypedResValueOp[ResMipMap] {
    type T = Drawable
    @TargetApi(21)
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
%9$s
  }
  implicit val trRawValueOp: TypedResValueOp[ResRaw] { type T = java.io.InputStream } = new TypedResValueOp[ResRaw] {
    type T = java.io.InputStream
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
      c.getResources.openRawResource(resid)
  }
  implicit val trStringValueOp: TypedResValueOp[ResString] { type T = String } = new TypedResValueOp[ResString] {
    type T = String
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
      c.getString(resid)
  }
  implicit val trXmlValueOp: TypedResValueOp[ResXml] { type T = XmlResourceParser } = new TypedResValueOp[ResXml] {
    type T = XmlResourceParser
    @inline final def resourceValue(resid: Int)(implicit c: Context): T =
      c.getResources.getXml(resid)
  }
  implicit val menuItemExtractor: Extractor[ResMenuItem, MenuItem] = new Extractor[ResMenuItem, MenuItem] {
    @inline final def matches(resid: Int, mi: MenuItem): Boolean = (mi.getItemId == resid)
  }

%10$s
}

